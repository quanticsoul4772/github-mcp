/**\n * Comprehensive Report Generator\n * \n * This module provides secure report generation with proper XSS protection\n * for both general reports and code analysis results.\n * All user input is properly escaped to prevent security vulnerabilities.\n */\n\nimport { \n  escapeHtml, \n  escapeHtmlAttribute, \n  safeHtmlTemplate, \n  safeStringify,\n  stripHtmlTags \n} from '../../utils/html-security.js';\nimport {\n  AnalysisReport,\n  CoordinationResult,\n  Finding,\n  Severity,\n  FindingCategory\n} from '../types.js';\nimport { logger } from '../../logger.js';\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\n\n/**\n * Interface for general report data\n */\nexport interface ReportData {\n  title: string;\n  summary: string;\n  sections: ReportSection[];\n  metadata: ReportMetadata;\n}\n\nexport interface ReportSection {\n  title: string;\n  content: string;\n  subsections?: ReportSubsection[];\n  data?: Record<string, unknown>;\n}\n\nexport interface ReportSubsection {\n  title: string;\n  content: string;\n  data?: Record<string, unknown>;\n}\n\nexport interface ReportMetadata {\n  generatedAt: Date;\n  generatedBy: string;\n  version: string;\n  repository?: string;\n  branch?: string;\n}\n\n/**\n * Interface for analysis report options\n */\nexport interface ReportOptions {\n  format: 'json' | 'markdown' | 'html' | 'console' | 'csv';\n  outputPath?: string;\n  includeDetails?: boolean;\n  groupBy?: 'severity' | 'category' | 'file';\n  sortBy?: 'severity' | 'category' | 'file' | 'line';\n  filterSeverity?: Severity[];\n  filterCategory?: FindingCategory[];\n  includeMetrics?: boolean;\n  includeRecommendations?: boolean;\n}\n\nexport interface ReportSummary {\n  totalFindings: number;\n  criticalFindings: number;\n  highFindings: number;\n  mediumFindings: number;\n  lowFindings: number;\n  infoFindings: number;\n  filesAnalyzed: number;\n  agentsUsed: string[];\n  analysisTime: number;\n  topIssues: Array<{\n    category: FindingCategory;\n    count: number;\n    severity: Severity;\n  }>;\n}\n\n/**\n * Comprehensive Report Generator\n * \n * This class generates both general HTML reports and code analysis reports\n * with proper security measures to prevent XSS attacks.\n * All user input is automatically escaped and validated.\n */\nexport class ReportGenerator {\n  private readonly cssStyles: string;\n\n  constructor() {\n    this.cssStyles = this.getDefaultStyles();\n  }\n\n  /**\n   * Generates a complete HTML report from the provided data\n   * \n   * @param data - The report data to render\n   * @returns A secure HTML string\n   */\n  public generateReport(data: ReportData): string {\n    this.validateReportData(data);\n\n    const escapedTitle = escapeHtml(data.title);\n    const escapedSummary = escapeHtml(data.summary);\n    \n    const sectionsHtml = data.sections\n      .map(section => this.renderSection(section))\n      .join('\\n');\n\n    const metadataHtml = this.renderMetadata(data.metadata);\n\n    return this.renderFullDocument({\n      title: escapedTitle,\n      summary: escapedSummary,\n      sections: sectionsHtml,\n      metadata: metadataHtml,\n      styles: this.cssStyles\n    });\n  }\n\n  /**\n   * Generate a report from analysis results\n   */\n  async generateAnalysisReport(\n    data: AnalysisReport | CoordinationResult,\n    options: ReportOptions\n  ): Promise<string> {\n    try {\n      logger.info('Generating analysis report', { format: options.format });\n\n      const summary = this.generateSummary(data);\n      const findings = this.extractFindings(data);\n      const filteredFindings = this.filterFindings(findings, options);\n      const groupedFindings = this.groupFindings(filteredFindings, options.groupBy);\n\n      let report: string;\n\n      switch (options.format) {\n        case 'json':\n          report = this.generateJsonReport(data, summary, filteredFindings, options);\n          break;\n        case 'markdown':\n          report = this.generateMarkdownReport(data, summary, groupedFindings, options);\n          break;\n        case 'html':\n          report = this.generateAnalysisHtmlReport(data, summary, groupedFindings, options);\n          break;\n        case 'console':\n          report = this.generateConsoleReport(data, summary, groupedFindings, options);\n          break;\n        case 'csv':\n          report = this.generateCsvReport(filteredFindings, options);\n          break;\n        default:\n          throw new Error(`Unsupported report format: ${options.format}`);\n      }\n\n      // Save to file if output path specified\n      if (options.outputPath) {\n        await this.saveReport(report, options.outputPath);\n        logger.info('Report saved', { path: options.outputPath });\n      }\n\n      return report;\n\n    } catch (error) {\n      logger.error('Failed to generate analysis report', { error });\n      throw error;\n    }\n  }\n\n  /**\n   * Renders a report section with proper escaping\n   */\n  private renderSection(section: ReportSection): string {\n    const escapedTitle = escapeHtml(section.title);\n    const escapedContent = escapeHtml(section.content);\n    \n    let subsectionsHtml = '';\n    if (section.subsections && section.subsections.length > 0) {\n      subsectionsHtml = section.subsections\n        .map(subsection => this.renderSubsection(subsection))\n        .join('\\n');\n    }\n\n    let dataHtml = '';\n    if (section.data) {\n      dataHtml = this.renderDataTable(section.data);\n    }\n\n    return `\n      <section class=\"report-section\">\n        <h2>${escapedTitle}</h2>\n        <div class=\"section-content\">${escapedContent}</div>\n        ${subsectionsHtml}\n        ${dataHtml}\n      </section>\n    `;\n  }\n\n  /**\n   * Renders a report subsection with proper escaping\n   */\n  private renderSubsection(subsection: ReportSubsection): string {\n    const escapedTitle = escapeHtml(subsection.title);\n    const escapedContent = escapeHtml(subsection.content);\n    \n    let dataHtml = '';\n    if (subsection.data) {\n      dataHtml = this.renderDataTable(subsection.data);\n    }\n\n    return `\n      <div class=\"report-subsection\">\n        <h3>${escapedTitle}</h3>\n        <div class=\"subsection-content\">${escapedContent}</div>\n        ${dataHtml}\n      </div>\n    `;\n  }\n\n  /**\n   * Renders a data table with proper escaping\n   */\n  private renderDataTable(data: Record<string, unknown>): string {\n    const rows = Object.entries(data)\n      .map(([key, value]) => {\n        const escapedKey = escapeHtml(key);\n        const escapedValue = safeStringify(value);\n        \n        return `\n          <tr>\n            <td class=\"data-key\">${escapedKey}</td>\n            <td class=\"data-value\">${escapedValue}</td>\n          </tr>\n        `;\n      })\n      .join('\\n');\n\n    return `\n      <table class=\"data-table\">\n        <thead>\n          <tr>\n            <th>Property</th>\n            <th>Value</th>\n          </tr>\n        </thead>\n        <tbody>\n          ${rows}\n        </tbody>\n      </table>\n    `;\n  }\n\n  /**\n   * Renders report metadata with proper escaping\n   */\n  private renderMetadata(metadata: ReportMetadata): string {\n    const escapedGeneratedBy = escapeHtml(metadata.generatedBy);\n    const escapedVersion = escapeHtml(metadata.version);\n    const escapedRepository = metadata.repository ? escapeHtml(metadata.repository) : '';\n    const escapedBranch = metadata.branch ? escapeHtml(metadata.branch) : '';\n    const formattedDate = escapeHtml(metadata.generatedAt.toISOString());\n\n    let repositoryInfo = '';\n    if (escapedRepository) {\n      repositoryInfo = `\n        <div class=\"metadata-item\">\n          <span class=\"metadata-label\">Repository:</span>\n          <span class=\"metadata-value\">${escapedRepository}</span>\n        </div>`;\n      \n      if (escapedBranch) {\n        repositoryInfo += `\n          <div class=\"metadata-item\">\n            <span class=\"metadata-label\">Branch:</span>\n            <span class=\"metadata-value\">${escapedBranch}</span>\n          </div>`;\n      }\n    }\n\n    return `\n      <div class=\"report-metadata\">\n        <h3>Report Information</h3>\n        <div class=\"metadata-grid\">\n          <div class=\"metadata-item\">\n            <span class=\"metadata-label\">Generated:</span>\n            <span class=\"metadata-value\">${formattedDate}</span>\n          </div>\n          <div class=\"metadata-item\">\n            <span class=\"metadata-label\">Generated By:</span>\n            <span class=\"metadata-value\">${escapedGeneratedBy}</span>\n          </div>\n          <div class=\"metadata-item\">\n            <span class=\"metadata-label\">Version:</span>\n            <span class=\"metadata-value\">${escapedVersion}</span>\n          </div>\n          ${repositoryInfo}\n        </div>\n      </div>\n    `;\n  }\n\n  /**\n   * Renders the complete HTML document\n   */\n  private renderFullDocument(parts: {\n    title: string;\n    summary: string;\n    sections: string;\n    metadata: string;\n    styles: string;\n  }): string {\n    // Note: parts.title, parts.summary are already escaped\n    // parts.sections, parts.metadata, parts.styles are safe HTML\n    return `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>${parts.title}</title>\n    <style>\n        ${parts.styles}\n    </style>\n</head>\n<body>\n    <div class=\"report-container\">\n        <header class=\"report-header\">\n            <h1>${parts.title}</h1>\n            <div class=\"report-summary\">${parts.summary}</div>\n        </header>\n        \n        <main class=\"report-content\">\n            ${parts.sections}\n        </main>\n        \n        <footer class=\"report-footer\">\n            ${parts.metadata}\n        </footer>\n    </div>\n</body>\n</html>`;\n  }\n\n  // Analysis Report Methods\n\n  /**\n   * Generate summary statistics\n   */\n  private generateSummary(data: AnalysisReport | CoordinationResult): ReportSummary {\n    const findings = this.extractFindings(data);\n    const isCoordination = 'reports' in data;\n\n    const severityCounts = {\n      [Severity.CRITICAL]: 0,\n      [Severity.HIGH]: 0,\n      [Severity.MEDIUM]: 0,\n      [Severity.LOW]: 0,\n      [Severity.INFO]: 0\n    };\n\n    const categoryCounts: Record<FindingCategory, number> = {} as Record<FindingCategory, number>;\n\n    findings.forEach(finding => {\n      severityCounts[finding.severity]++;\n      categoryCounts[finding.category] = (categoryCounts[finding.category] || 0) + 1;\n    });\n\n    // Get top issues\n    const topIssues = Object.entries(categoryCounts)\n      .map(([category, count]) => ({\n        category: category as FindingCategory,\n        count,\n        severity: this.getTypicalSeverityForCategory(category as FindingCategory, findings)\n      }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 5);\n\n    return {\n      totalFindings: findings.length,\n      criticalFindings: severityCounts[Severity.CRITICAL],\n      highFindings: severityCounts[Severity.HIGH],\n      mediumFindings: severityCounts[Severity.MEDIUM],\n      lowFindings: severityCounts[Severity.LOW],\n      infoFindings: severityCounts[Severity.INFO],\n      filesAnalyzed: isCoordination \n        ? data.reports.reduce((sum, r) => sum + r.summary.filesAnalyzed, 0)\n        : data.summary.filesAnalyzed,\n      agentsUsed: isCoordination \n        ? data.summary.agentsUsed \n        : [data.agentName],\n      analysisTime: isCoordination \n        ? data.summary.totalDuration \n        : data.duration,\n      topIssues\n    };\n  }\n\n  /**\n   * Extract findings from data\n   */\n  private extractFindings(data: AnalysisReport | CoordinationResult): Finding[] {\n    if ('reports' in data) {\n      return data.consolidatedFindings;\n    }\n    return data.findings;\n  }\n\n  /**\n   * Filter findings based on options\n   */\n  private filterFindings(findings: Finding[], options: ReportOptions): Finding[] {\n    let filtered = findings;\n\n    if (options.filterSeverity && options.filterSeverity.length > 0) {\n      filtered = filtered.filter(f => options.filterSeverity!.includes(f.severity));\n    }\n\n    if (options.filterCategory && options.filterCategory.length > 0) {\n      filtered = filtered.filter(f => options.filterCategory!.includes(f.category));\n    }\n\n    // Sort findings\n    if (options.sortBy) {\n      filtered = this.sortFindings(filtered, options.sortBy);\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Group findings by specified criteria\n   */\n  private groupFindings(\n    findings: Finding[], \n    groupBy?: 'severity' | 'category' | 'file'\n  ): Record<string, Finding[]> {\n    if (!groupBy) {\n      return { all: findings };\n    }\n\n    const groups: Record<string, Finding[]> = {};\n\n    findings.forEach(finding => {\n      let key: string;\n      \n      switch (groupBy) {\n        case 'severity':\n          key = finding.severity;\n          break;\n        case 'category':\n          key = finding.category;\n          break;\n        case 'file':\n          key = finding.file;\n          break;\n        default:\n          key = 'all';\n      }\n\n      if (!groups[key]) {\n        groups[key] = [];\n      }\n      groups[key].push(finding);\n    });\n\n    return groups;\n  }\n\n  /**\n   * Sort findings by specified criteria\n   */\n  private sortFindings(findings: Finding[], sortBy: string): Finding[] {\n    const severityOrder = [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW, Severity.INFO];\n    const list = findings.slice();\n\n    return list.sort((a, b) => {\n      switch (sortBy) {\n        case 'severity':\n          return severityOrder.indexOf(a.severity) - severityOrder.indexOf(b.severity);\n        case 'category':\n          return a.category.localeCompare(b.category);\n        case 'file':\n          return a.file.localeCompare(b.file);\n        case 'line':\n          if (a.file !== b.file) return a.file.localeCompare(b.file);\n          return (a.line || 0) - (b.line || 0);\n        default:\n          return 0;\n      }\n    });\n  }\n\n  /**\n   * Generate JSON report\n   */\n  private generateJsonReport(\n    data: AnalysisReport | CoordinationResult,\n    summary: ReportSummary,\n    findings: Finding[],\n    options: ReportOptions\n  ): string {\n    const report = {\n      metadata: {\n        generatedAt: new Date().toISOString(),\n        format: 'json',\n        version: '1.0.0'\n      },\n      summary,\n      ...(options.includeDetails && { data }),\n      findings: options.includeDetails ? findings : findings.map(f => ({\n        id: f.id,\n        severity: f.severity,\n        category: f.category,\n        title: f.title,\n        file: f.file,\n        line: f.line\n      }))\n    };\n\n    return JSON.stringify(report, null, 2);\n  }\n\n  /**\n   * Generate Markdown report\n   */\n  private generateMarkdownReport(\n    data: AnalysisReport | CoordinationResult,\n    summary: ReportSummary,\n    groupedFindings: Record<string, Finding[]>,\n    options: ReportOptions\n  ): string {\n    let report = '# Code Analysis Report\\n\\n';\n    \n    // Metadata\n    report += `**Generated:** ${new Date().toISOString()}\\n`;\n    report += `**Agents Used:** ${summary.agentsUsed.join(', ')}\\n`;\n    report += `**Analysis Time:** ${Math.round(summary.analysisTime)}ms\\n\\n`;\n\n    // Summary\n    report += '## Summary\\n\\n';\n    report += `- **Total Findings:** ${summary.totalFindings}\\n`;\n    report += `- **Files Analyzed:** ${summary.filesAnalyzed}\\n`;\n    report += `- **Critical Issues:** ${summary.criticalFindings}\\n`;\n    report += `- **High Priority:** ${summary.highFindings}\\n`;\n    report += `- **Medium Priority:** ${summary.mediumFindings}\\n`;\n    report += `- **Low Priority:** ${summary.lowFindings}\\n`;\n    report += `- **Info:** ${summary.infoFindings}\\n\\n`;\n\n    // Severity distribution chart\n    report += '### Severity Distribution\\n\\n';\n    report += '```\\n';\n    const maxCount = Math.max(\n      summary.criticalFindings,\n      summary.highFindings,\n      summary.mediumFindings,\n      summary.lowFindings,\n      summary.infoFindings\n    );\n    \n    if (maxCount > 0) {\n      const severities = [\n        { name: 'Critical', count: summary.criticalFindings, symbol: '🔴' },\n        { name: 'High', count: summary.highFindings, symbol: '🟠' },\n        { name: 'Medium', count: summary.mediumFindings, symbol: '🟡' },\n        { name: 'Low', count: summary.lowFindings, symbol: '🔵' },\n        { name: 'Info', count: summary.infoFindings, symbol: '⚪' }\n      ];\n\n      severities.forEach(sev => {\n        const barLength = Math.round((sev.count / maxCount) * 20);\n        const bar = '█'.repeat(barLength).padEnd(20, '░');\n        report += `${sev.symbol} ${sev.name.padEnd(8)} │${bar}│ ${sev.count}\\n`;\n      });\n    }\n    report += '```\\n\\n';\n\n    // Top issues\n    if (summary.topIssues.length > 0) {\n      report += '### Top Issues\\n\\n';\n      summary.topIssues.forEach((issue, index) => {\n        const emoji = this.getSeverityEmoji(issue.severity);\n        report += `${index + 1}. ${emoji} **${issue.category.replace(/_/g, ' ')}** (${issue.count} occurrences)\\n`;\n      });\n      report += '\\n';\n    }\n\n    // Detailed findings\n    if (options.includeDetails) {\n      report += '## Detailed Findings\\n\\n';\n      \n      Object.entries(groupedFindings).forEach(([group, findings]) => {\n        if (findings.length === 0) return;\n        \n        report += `### ${this.formatGroupName(group)}\\n\\n`;\n        \n        findings.forEach(finding => {\n          const emoji = this.getSeverityEmoji(finding.severity);\n          report += `#### ${emoji} ${finding.title}\\n\\n`;\n          report += `- **File:** \\`${finding.file}\\`\\n`;\n          if (finding.line) report += `- **Line:** ${finding.line}\\n`;\n          report += `- **Severity:** ${finding.severity}\\n`;\n          report += `- **Category:** ${finding.category.replace(/_/g, ' ')}\\n`;\n          if (finding.rule) report += `- **Rule:** ${finding.rule}\\n`;\n          report += `\\n**Description:** ${finding.description}\\n\\n`;\n          \n          if (finding.snippet) {\n            report += '**Code:**\\n```typescript\\n';\n            report += finding.snippet;\n            report += '\\n```\\n\\n';\n          }\n          \n          if (finding.suggestion) {\n            report += `**Suggestion:** ${finding.suggestion}\\n\\n`;\n          }\n          \n          report += '---\\n\\n';\n        });\n      });\n    }\n\n    // Recommendations\n    if (options.includeRecommendations) {\n      report += this.generateRecommendations(summary);\n    }\n\n    return report;\n  }\n\n  /**\n   * Generate HTML report for analysis results\n   */\n  private generateAnalysisHtmlReport(\n    data: AnalysisReport | CoordinationResult,\n    summary: ReportSummary,\n    groupedFindings: Record<string, Finding[]>,\n    options: ReportOptions\n  ): string {\n    let html = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Code Analysis Report</title>\n    <style>\n        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }\n        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }\n        h1 { color: #333; border-bottom: 3px solid #007acc; padding-bottom: 10px; }\n        h2 { color: #555; margin-top: 30px; }\n        .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0; }\n        .stat-card { background: #f8f9fa; padding: 20px; border-radius: 6px; text-align: center; border-left: 4px solid #007acc; }\n        .stat-number { font-size: 2em; font-weight: bold; color: #007acc; }\n        .stat-label { color: #666; margin-top: 5px; }\n        .severity-critical { border-left-color: #dc3545; color: #dc3545; }\n        .severity-high { border-left-color: #fd7e14; color: #fd7e14; }\n        .severity-medium { border-left-color: #ffc107; color: #ffc107; }\n        .severity-low { border-left-color: #17a2b8; color: #17a2b8; }\n        .finding { background: #f8f9fa; margin: 15px 0; padding: 20px; border-radius: 6px; border-left: 4px solid #dee2e6; }\n        .finding-title { font-weight: bold; margin-bottom: 10px; }\n        .finding-meta { color: #666; font-size: 0.9em; margin-bottom: 10px; }\n        .finding-description { margin-bottom: 15px; }\n        .code-snippet { background: #f1f3f4; padding: 15px; border-radius: 4px; font-family: 'Courier New', monospace; overflow-x: auto; }\n        .suggestion { background: #e7f3ff; padding: 15px; border-radius: 4px; border-left: 4px solid #007acc; }\n        .chart { margin: 20px 0; }\n        .bar { display: flex; align-items: center; margin: 5px 0; }\n        .bar-label { width: 80px; font-size: 0.9em; }\n        .bar-visual { flex: 1; height: 20px; background: #e9ecef; border-radius: 10px; margin: 0 10px; overflow: hidden; }\n        .bar-fill { height: 100%; border-radius: 10px; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>🔍 Code Analysis Report</h1>\n        \n        <div class=\"meta\">\n            <p><strong>Generated:</strong> ${new Date().toISOString()}</p>\n            <p><strong>Agents Used:</strong> ${summary.agentsUsed.join(', ')}</p>\n            <p><strong>Analysis Time:</strong> ${Math.round(summary.analysisTime)}ms</p>\n        </div>\n\n        <h2>📊 Summary</h2>\n        <div class=\"summary\">\n            <div class=\"stat-card\">\n                <div class=\"stat-number\">${summary.totalFindings}</div>\n                <div class=\"stat-label\">Total Findings</div>\n            </div>\n            <div class=\"stat-card\">\n                <div class=\"stat-number\">${summary.filesAnalyzed}</div>\n                <div class=\"stat-label\">Files Analyzed</div>\n            </div>\n            <div class=\"stat-card severity-critical\">\n                <div class=\"stat-number\">${summary.criticalFindings}</div>\n                <div class=\"stat-label\">Critical</div>\n            </div>\n            <div class=\"stat-card severity-high\">\n                <div class=\"stat-number\">${summary.highFindings}</div>\n                <div class=\"stat-label\">High</div>\n            </div>\n            <div class=\"stat-card severity-medium\">\n                <div class=\"stat-number\">${summary.mediumFindings}</div>\n                <div class=\"stat-label\">Medium</div>\n            </div>\n            <div class=\"stat-card severity-low\">\n                <div class=\"stat-number\">${summary.lowFindings}</div>\n                <div class=\"stat-label\">Low</div>\n            </div>\n        </div>`;\n\n    // Add severity distribution chart\n    const maxCount = Math.max(\n      summary.criticalFindings,\n      summary.highFindings,\n      summary.mediumFindings,\n      summary.lowFindings,\n      summary.infoFindings\n    );\n\n    if (maxCount > 0) {\n      html += `\n        <h2>📈 Severity Distribution</h2>\n        <div class=\"chart\">`;\n\n      const severities = [\n        { name: 'Critical', count: summary.criticalFindings, color: '#dc3545' },\n        { name: 'High', count: summary.highFindings, color: '#fd7e14' },\n        { name: 'Medium', count: summary.mediumFindings, color: '#ffc107' },\n        { name: 'Low', count: summary.lowFindings, color: '#17a2b8' },\n        { name: 'Info', count: summary.infoFindings, color: '#6c757d' }\n      ];\n\n      severities.forEach(sev => {\n        const percentage = (sev.count / maxCount) * 100;\n        html += `\n            <div class=\"bar\">\n                <div class=\"bar-label\">${sev.name}</div>\n                <div class=\"bar-visual\">\n                    <div class=\"bar-fill\" style=\"width: ${percentage}%; background-color: ${sev.color};\"></div>\n                </div>\n                <div style=\"width: 40px; text-align: right;\">${sev.count}</div>\n            </div>`;\n      });\n\n      html += `</div>`;\n    }\n\n    // Add detailed findings if requested\n    if (options.includeDetails) {\n      html += `<h2>🔍 Detailed Findings</h2>`;\n      \n      Object.entries(groupedFindings).forEach(([group, findings]) => {\n        if (findings.length === 0) return;\n        \n        html += `<h3>${this.formatGroupName(group)}</h3>`;\n        \n        findings.forEach(finding => {\n          const severityClass = `severity-${finding.severity}`;\n          html += `\n            <div class=\"finding ${severityClass}\">\n                <div class=\"finding-title\">${this.getSeverityEmoji(finding.severity)} ${escapeHtml(finding.title)}</div>\n                <div class=\"finding-meta\">\n                    📁 ${escapeHtml(finding.file)}${finding.line ? ` : ${finding.line}` : ''} | \n                    🏷️ ${finding.category.replace(/_/g, ' ')} | \n                    ⚠️ ${finding.severity}\n                </div>\n                <div class=\"finding-description\">${escapeHtml(finding.description)}</div>`;\n          \n          if (finding.snippet) {\n            html += `<div class=\"code-snippet\">${escapeHtml(finding.snippet)}</div>`;\n          }\n          \n          if (finding.suggestion) {\n            html += `<div class=\"suggestion\"><strong>💡 Suggestion:</strong> ${escapeHtml(finding.suggestion)}</div>`;\n          }\n          \n          html += `</div>`;\n        });\n      });\n    }\n\n    html += `\n    </div>\n</body>\n</html>`;\n\n    return html;\n  }\n\n  /**\n   * Generate console report\n   */\n  private generateConsoleReport(\n    data: AnalysisReport | CoordinationResult,\n    summary: ReportSummary,\n    groupedFindings: Record<string, Finding[]>,\n    options: ReportOptions\n  ): string {\n    let report = '';\n    \n    // Header\n    report += '╔══════════════════════════════════════════════════════════════════════════════╗\\n';\n    report += '║                            CODE ANALYSIS REPORT                             ║\\n';\n    report += '╚══════════════════════════════════════════════════════════════════════════════╝\\n\\n';\n\n    // Summary\n    report += `📊 SUMMARY\\n`;\n    report += `${'─'.repeat(50)}\\n`;\n    report += `Total Findings:     ${summary.totalFindings}\\n`;\n    report += `Files Analyzed:     ${summary.filesAnalyzed}\\n`;\n    report += `Analysis Time:      ${Math.round(summary.analysisTime)}ms\\n`;\n    report += `Agents Used:        ${summary.agentsUsed.join(', ')}\\n\\n`;\n\n    // Severity breakdown\n    report += `🚨 SEVERITY BREAKDOWN\\n`;\n    report += `${'─'.repeat(50)}\\n`;\n    report += `🔴 Critical:        ${summary.criticalFindings}\\n`;\n    report += `🟠 High:            ${summary.highFindings}\\n`;\n    report += `🟡 Medium:          ${summary.mediumFindings}\\n`;\n    report += `🔵 Low:             ${summary.lowFindings}\\n`;\n    report += `⚪ Info:            ${summary.infoFindings}\\n\\n`;\n\n    // Top issues\n    if (summary.topIssues.length > 0) {\n      report += `🎯 TOP ISSUES\\n`;\n      report += `${'─'.repeat(50)}\\n`;\n      summary.topIssues.forEach((issue, index) => {\n        const emoji = this.getSeverityEmoji(issue.severity);\n        report += `${index + 1}. ${emoji} ${issue.category.replace(/_/g, ' ')} (${issue.count})\\n`;\n      });\n      report += '\\n';\n    }\n\n    // Detailed findings\n    if (options.includeDetails) {\n      report += `🔍 DETAILED FINDINGS\\n`;\n      report += `${'═'.repeat(80)}\\n\\n`;\n      \n      Object.entries(groupedFindings).forEach(([group, findings]) => {\n        if (findings.length === 0) return;\n        \n        report += `📁 ${this.formatGroupName(group).toUpperCase()}\\n`;\n        report += `${'─'.repeat(50)}\\n`;\n        \n        findings.forEach((finding, index) => {\n          const emoji = this.getSeverityEmoji(finding.severity);\n          report += `${index + 1}. ${emoji} ${finding.title}\\n`;\n          report += `   📍 ${finding.file}${finding.line ? `:${finding.line}` : ''}\\n`;\n          report += `   🏷️  ${finding.category.replace(/_/g, ' ')} | ⚠️  ${finding.severity}\\n`;\n          report += `   📝 ${finding.description}\\n`;\n          \n          if (finding.suggestion) {\n            report += `   💡 ${finding.suggestion}\\n`;\n          }\n          \n          report += '\\n';\n        });\n        \n        report += '\\n';\n      });\n    }\n\n    return report;\n  }\n\n  /**\n   * Generate CSV report\n   */\n  private generateCsvReport(findings: Finding[], options: ReportOptions): string {\n    const headers = [\n      'ID',\n      'Severity',\n      'Category',\n      'Title',\n      'Description',\n      'File',\n      'Line',\n      'Column',\n      'Rule',\n      'Suggestion'\n    ];\n\n    let csv = headers.join(',') + '\\n';\n\n    findings.forEach(finding => {\n      const row = [\n        this.escapeCsv(finding.id),\n        this.escapeCsv(finding.severity),\n        this.escapeCsv(finding.category),\n        this.escapeCsv(finding.title),\n        this.escapeCsv(finding.description),\n        this.escapeCsv(finding.file),\n        finding.line?.toString() || '',\n        finding.column?.toString() || '',\n        this.escapeCsv(finding.rule || ''),\n        this.escapeCsv(finding.suggestion || '')\n      ];\n      csv += row.join(',') + '\\n';\n    });\n\n    return csv;\n  }\n\n  /**\n   * Generate recommendations based on analysis results\n   */\n  private generateRecommendations(summary: ReportSummary): string {\n    let recommendations = '## 💡 Recommendations\\n\\n';\n\n    if (summary.criticalFindings > 0) {\n      recommendations += '### 🚨 Immediate Action Required\\n';\n      recommendations += `You have ${summary.criticalFindings} critical issues that need immediate attention. These could lead to security vulnerabilities or system failures.\\n\\n`;\n    }\n\n    if (summary.highFindings > 0) {\n      recommendations += '### ⚠️ High Priority\\n';\n      recommendations += `Address ${summary.highFindings} high-priority issues to improve code reliability and maintainability.\\n\\n`;\n    }\n\n    if (summary.topIssues.length > 0) {\n      recommendations += '### 🎯 Focus Areas\\n';\n      recommendations += 'Based on the analysis, focus on these areas:\\n\\n';\n      \n      summary.topIssues.slice(0, 3).forEach((issue, index) => {\n        recommendations += `${index + 1}. **${issue.category.replace(/_/g, ' ')}** - Found ${issue.count} instances\\n`;\n      });\n      recommendations += '\\n';\n    }\n\n    // General recommendations based on findings\n    recommendations += '### 📋 General Recommendations\\n\\n';\n    recommendations += '- Set up automated code quality checks in your CI/CD pipeline\\n';\n    recommendations += '- Consider using a linter with stricter rules\\n';\n    recommendations += '- Implement code review processes\\n';\n    recommendations += '- Add comprehensive test coverage\\n';\n    recommendations += '- Document coding standards for your team\\n\\n';\n\n    return recommendations;\n  }\n\n  // Helper methods\n\n  private getSeverityEmoji(severity: Severity): string {\n    const emojiMap = {\n      [Severity.CRITICAL]: '🔴',\n      [Severity.HIGH]: '🟠',\n      [Severity.MEDIUM]: '🟡',\n      [Severity.LOW]: '🔵',\n      [Severity.INFO]: '⚪'\n    };\n    return emojiMap[severity] || '⚪';\n  }\n\n  private formatGroupName(group: string): string {\n    return group.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n  }\n\n  private getTypicalSeverityForCategory(category: FindingCategory, findings: Finding[]): Severity {\n    const categoryFindings = findings.filter(f => f.category === category);\n    if (categoryFindings.length === 0) return Severity.INFO;\n    \n    // Return the most common severity for this category\n    const severityCounts = categoryFindings.reduce((acc, f) => {\n      acc[f.severity] = (acc[f.severity] || 0) + 1;\n      return acc;\n    }, {} as Record<Severity, number>);\n    \n    return Object.entries(severityCounts)\n      .sort(([,a], [,b]) => b - a)[0][0] as Severity;\n  }\n\n  private escapeCsv(text: string): string {\n    if (text.includes(',') || text.includes('\"') || text.includes('\\n')) {\n      return `\"${text.replace(/\"/g, '\"\"')}\"`;\n    }\n    return text;\n  }\n\n  private async saveReport(content: string, outputPath: string): Promise<void> {\n    try {\n      // Ensure directory exists\n      const dir = path.dirname(outputPath);\n      await fs.mkdir(dir, { recursive: true });\n      \n      // Write file\n      await fs.writeFile(outputPath, content, 'utf-8');\n    } catch (error) {\n      logger.error('Failed to save report', { error, path: outputPath });\n      throw error;\n    }\n  }\n\n  /**\n   * Validates report data to ensure it's safe to process\n   */\n  private validateReportData(data: ReportData): void {\n    if (!data || typeof data !== 'object') {\n      throw new Error('Report data must be a valid object');\n    }\n\n    if (!data.title || typeof data.title !== 'string') {\n      throw new Error('Report title must be a non-empty string');\n    }\n\n    if (!data.summary || typeof data.summary !== 'string') {\n      throw new Error('Report summary must be a non-empty string');\n    }\n\n    if (!Array.isArray(data.sections)) {\n      throw new Error('Report sections must be an array');\n    }\n\n    if (!data.metadata || typeof data.metadata !== 'object') {\n      throw new Error('Report metadata must be a valid object');\n    }\n\n    // Validate each section\n    data.sections.forEach((section, index) => {\n      if (!section.title || typeof section.title !== 'string') {\n        throw new Error(`Section ${index} must have a valid title`);\n      }\n      if (!section.content || typeof section.content !== 'string') {\n        throw new Error(`Section ${index} must have valid content`);\n      }\n    });\n  }\n\n  /**\n   * Gets the default CSS styles for reports\n   */\n  private getDefaultStyles(): string {\n    // CSS is safe to include directly as it doesn't contain user input\n    return `\n      * {\n        box-sizing: border-box;\n        margin: 0;\n        padding: 0;\n      }\n\n      body {\n        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n        line-height: 1.6;\n        color: #333;\n        background-color: #f5f5f5;\n      }\n\n      .report-container {\n        max-width: 1200px;\n        margin: 0 auto;\n        background: white;\n        box-shadow: 0 0 10px rgba(0,0,0,0.1);\n        min-height: 100vh;\n      }\n\n      .report-header {\n        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n        color: white;\n        padding: 2rem;\n        text-align: center;\n      }\n\n      .report-header h1 {\n        font-size: 2.5rem;\n        margin-bottom: 1rem;\n        font-weight: 300;\n      }\n\n      .report-summary {\n        font-size: 1.2rem;\n        opacity: 0.9;\n        max-width: 800px;\n        margin: 0 auto;\n      }\n\n      .report-content {\n        padding: 2rem;\n      }\n\n      .report-section {\n        margin-bottom: 3rem;\n        border-bottom: 1px solid #eee;\n        padding-bottom: 2rem;\n      }\n\n      .report-section:last-child {\n        border-bottom: none;\n        margin-bottom: 0;\n      }\n\n      .report-section h2 {\n        color: #2c3e50;\n        font-size: 1.8rem;\n        margin-bottom: 1rem;\n        border-left: 4px solid #667eea;\n        padding-left: 1rem;\n      }\n\n      .section-content {\n        margin-bottom: 1.5rem;\n        font-size: 1.1rem;\n        line-height: 1.7;\n      }\n\n      .report-subsection {\n        margin: 1.5rem 0;\n        padding-left: 1rem;\n        border-left: 2px solid #ddd;\n      }\n\n      .report-subsection h3 {\n        color: #34495e;\n        font-size: 1.4rem;\n        margin-bottom: 0.5rem;\n      }\n\n      .subsection-content {\n        margin-bottom: 1rem;\n      }\n\n      .data-table {\n        width: 100%;\n        border-collapse: collapse;\n        margin: 1rem 0;\n        background: white;\n        border-radius: 8px;\n        overflow: hidden;\n        box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n      }\n\n      .data-table th,\n      .data-table td {\n        padding: 0.75rem 1rem;\n        text-align: left;\n        border-bottom: 1px solid #eee;\n      }\n\n      .data-table th {\n        background: #f8f9fa;\n        font-weight: 600;\n        color: #2c3e50;\n      }\n\n      .data-table tr:hover {\n        background: #f8f9fa;\n      }\n\n      .data-key {\n        font-weight: 500;\n        color: #555;\n        width: 30%;\n      }\n\n      .data-value {\n        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;\n        font-size: 0.9rem;\n        word-break: break-all;\n      }\n\n      .report-footer {\n        background: #f8f9fa;\n        padding: 2rem;\n        border-top: 1px solid #eee;\n      }\n\n      .report-metadata h3 {\n        color: #2c3e50;\n        margin-bottom: 1rem;\n      }\n\n      .metadata-grid {\n        display: grid;\n        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n        gap: 1rem;\n      }\n\n      .metadata-item {\n        display: flex;\n        flex-direction: column;\n      }\n\n      .metadata-label {\n        font-weight: 600;\n        color: #555;\n        font-size: 0.9rem;\n        margin-bottom: 0.25rem;\n      }\n\n      .metadata-value {\n        color: #333;\n        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;\n        font-size: 0.9rem;\n      }\n\n      @media (max-width: 768px) {\n        .report-header {\n          padding: 1.5rem 1rem;\n        }\n\n        .report-header h1 {\n          font-size: 2rem;\n        }\n\n        .report-content {\n          padding: 1rem;\n        }\n\n        .metadata-grid {\n          grid-template-columns: 1fr;\n        }\n      }\n    `;\n  }\n\n  /**\n   * Generates a plain text version of the report\n   */\n  public generatePlainTextReport(data: ReportData): string {\n    this.validateReportData(data);\n\n    const lines: string[] = [];\n    \n    // Title and summary\n    lines.push(data.title.toUpperCase());\n    lines.push('='.repeat(data.title.length));\n    lines.push('');\n    lines.push(data.summary);\n    lines.push('');\n\n    // Sections\n    data.sections.forEach(section => {\n      lines.push(section.title);\n      lines.push('-'.repeat(section.title.length));\n      lines.push(stripHtmlTags(section.content)); // Strip HTML for plain text\n      lines.push('');\n\n      if (section.subsections) {\n        section.subsections.forEach(subsection => {\n          lines.push(`  ${subsection.title}`);\n          lines.push(`  ${stripHtmlTags(subsection.content)}`);\n          lines.push('');\n        });\n      }\n\n      if (section.data) {\n        Object.entries(section.data).forEach(([key, value]) => {\n          const stringValue = typeof value === 'string' ? stripHtmlTags(value) : String(value);\n          lines.push(`  ${key}: ${stringValue}`);\n        });\n        lines.push('');\n      }\n    });\n\n    // Metadata\n    lines.push('REPORT INFORMATION');\n    lines.push('-'.repeat(18));\n    lines.push(`Generated: ${data.metadata.generatedAt.toISOString()}`);\n    lines.push(`Generated By: ${data.metadata.generatedBy}`);\n    lines.push(`Version: ${data.metadata.version}`);\n    \n    if (data.metadata.repository) {\n      lines.push(`Repository: ${data.metadata.repository}`);\n    }\n    \n    if (data.metadata.branch) {\n      lines.push(`Branch: ${data.metadata.branch}`);\n    }\n\n    return lines.join('\\n');\n  }\n}\n\n/**\n * Factory function to create a new report generator instance\n */\nexport function createReportGenerator(): ReportGenerator {\n  return new ReportGenerator();\n}\n\n/**\n * Convenience function to generate an HTML report\n */\nexport function generateHtmlReport(data: ReportData): string {\n  const generator = createReportGenerator();\n  return generator.generateReport(data);\n}\n\n/**\n * Convenience function to generate a plain text report\n */\nexport function generatePlainTextReport(data: ReportData): string {\n  const generator = createReportGenerator();\n  return generator.generatePlainTextReport(data);\n}\n\n/**\n * Convenience function to generate an analysis report\n */\nexport function generateAnalysisReport(\n  data: AnalysisReport | CoordinationResult,\n  options: ReportOptions\n): Promise<string> {\n  const generator = createReportGenerator();\n  return generator.generateAnalysisReport(data, options);\n}"